/**
 * Collection of static utility methods to manipulate the D3 image.
 *
 * Created by dmitri on 12/05/16.
 */
'use strict';

import d3 from 'd3';

import D3EventHandlers from './D3EventHandlers';

import Classes from '../constants/CommonSVGClasses';
import ViewConstants from '../constants/ViewConstants';

import ViewActions from '../actions/ViewActions';

import markerSVG from '../images/poi.svg';
import resizeHandleIcon from '../images/resize-handle.svg';

export default class D3ViewUtils {
  /**
   * Draws or updates the drawing of the lab bench data. This is the main rendering method for the lab bench.
   * Each new element to be drawn must follow the classic D3 enter-exit-update pattern (see D3 documentation) for performance and code readability reasons. Also to avoid bugs and headaches.
   * @param data displayed data representation element generated by components/bench/D3FreeSpace::buildDisplayDataElement
   * @param self reference to the D3FreeSpace element (only the stores are used here).
   */
  static drawBenchData(data, self) {
    let root = d3.select('.' + Classes.OBJECTS_CONTAINER_CLASS);
    let children = root.selectAll('.' + Classes.CHILD_GROUP_CLASS)
      .data(data, d => d.link);
    let displays = self.viewstore.getDisplayedTypes();
    let colors = self.viewstore.getColors();

    // One group per entity displayed in lab bench (i.e. per View-Entity link).
    children.enter()
      .append('g')
      .attr('class', Classes.CHILD_GROUP_CLASS)
      .attr('id', d => 'GROUP-' + d.link)
      .attr('transform', function(d) {
        return d.x === null|| d.y === null || d.displayHeight === null || d.height === null ? '' : 'translate(' + d.x + ',' + d.y + ')scale(' + (d.displayHeight / d.height) + ')'});
    children.exit().remove();
    children.attr('transform', d => d.x === null|| d.y === null || d.displayHeight === null || d.height === null ? '' : 'translate(' + d.x + ',' + d.y + ')scale(' + (d.displayHeight/d.height) + ')');

    // BEGIN under image update (borders, image title and actions such as drag and resize go here)
      let under = children.selectAll('.' + Classes.UNDER_CHILD_CLASS).data(d => [d], d => d.link);
      under.enter()
        .append('g')
        .attr('class', d => Classes.UNDER_CHILD_CLASS)
        .attr('id', d => 'UNDER-' + d.link);
      under.exit().remove();
      under.attr('id', d => 'UNDER-' + d.link);

    if(displays.borders) {
      let borderAreas = under.selectAll('.' + Classes.BORDER_CLASS).data(d => [d], d => d.link);
      borderAreas.enter()
        .append('rect')
        .attr('class', Classes.BORDER_CLASS)
        .attr('id', d => 'BORDER-' + d.link)
        .attr('x', d => -5 / self.view.scale * d.height / d.displayHeight)
        .attr('y', d => -20 / self.view.scale * d.height / d.displayHeight)
        .attr('width', d => d.width + 10 / self.view.scale * d.height / d.displayHeight)
        .attr('height', d => d.height + 30 / self.view.scale * d.height / d.displayHeight)
        .style('fill', d => colors[d.uid]?colors[d.uid][0]:'#AAAAAA');
      borderAreas.exit().remove();
      borderAreas
        .attr('x', d => -5 / self.view.scale * d.height / d.displayHeight)
        .attr('y', d => -20 / self.view.scale * d.height / d.displayHeight)
        .attr('width', d => d.width + 10 / self.view.scale * d.height / d.displayHeight)
        .attr('height', d => d.height + 30 / self.view.scale * d.height / d.displayHeight)
        .style('fill', d => colors[d.uid]?colors[d.uid][0]:'#AAAAAA');

      let namePath = under.selectAll('.' + Classes.NAME_PATH_CLASS).data(d => [d], d => d.link);
      namePath.enter()
        .append('path')
        .attr('id', d => 'NAME-PATH-' + d.link)
        .attr('class', Classes.NAME_PATH_CLASS)
        .attr('d', d => 'M 0 ' + (-5 * d.height/d.displayHeight)/self.view.scale + ' L ' + (d.width) + ' ' + (-5 * d.height/d.displayHeight)/self.view.scale)
        .style('pointer-events', 'none');
      namePath.exit().remove();
      namePath
        .attr('d', d => 'M 0 ' + (-5 * d.height/d.displayHeight)/self.view.scale + ' L ' + (d.width) + ' ' + (-5 * d.height/d.displayHeight)/self.view.scale)
        .style('pointer-events', 'none');

      let name = under.selectAll('.' + Classes.NAME_CLASS).data(d => [d], d => d.link);
      name.enter().append('text')
        .attr('class', Classes.NAME_CLASS)
        .attr('id', d => 'NAME-' + d.link)
        .attr('x', 10)
        .attr('font-family', 'Verdana')
        .attr('font-size', d => 14 / self.view.scale * d.height / d.displayHeight + 'px')
        .attr('fill', 'white')
        .append('textPath')
        .attr('xlink:href', d => '#NAME-PATH-' + d.link)
        .style('pointer-events', 'none')
        .text(d => d.name);
      name.exit().remove();
      name.attr('font-size', d => 14 / self.view.scale * d.height / d.displayHeight + 'px')
        .select('textPath')
        .style('pointer-events', 'none')
        .text(d => d.name);

      let resizer = under.selectAll('.' + Classes.RESIZE_CLASS).data(d => [d], d => d.link);
      resizer.enter()
        .append('svg:image')
        .attr('xlink:href', resizeHandleIcon)
        .attr('class', Classes.RESIZE_CLASS)
        .attr('id', d => 'RESIZE-' + d.link)
        .attr('x', d => d.width - 5 / self.view.scale * d.height / d.displayHeight)
        .attr('y', d => d.height)
        .attr('width', d => 10 / self.view.scale * d.height / d.displayHeight)
        .attr('height', d => 10 / self.view.scale * d.height / d.displayHeight)
        .call(D3EventHandlers.dragResize())
        .style('cursor', '-webkit-nwse-resize')
        .style('cursor', 'nwse-resize');
      resizer.exit().remove();
      resizer
        .attr('x', d => d.width - 5 / self.view.scale * d.height / d.displayHeight)
        .attr('y', d => d.height)
        .attr('width', d => 10 / self.view.scale * d.height / d.displayHeight)
        .attr('height', d => 10 / self.view.scale * d.height / d.displayHeight);

      if (self.modestore.isInObservationMode()) {
        borderAreas.style('cursor', '-webkit-grab')
          .style('cursor', 'grab')
          .call(D3EventHandlers.dragMove());
      }
    }
    else {
      under.selectAll('.' + Classes.BORDER_CLASS).remove();
      under.selectAll('.' + Classes.NAME_PATH_CLASS).remove();
      under.selectAll('.' + Classes.NAME_CLASS).remove();
      under.selectAll('.' + Classes.RESIZE_CLASS).remove();
    }
    // END under image update

    // Create the image representation of the entity
    let image = children.selectAll('.' + Classes.IMAGE_CLASS).data(d => [d], d => d.link);
    image.enter().append('svg:image')
      .attr('class', Classes.IMAGE_CLASS)
      .attr('id', d => 'IMAGE-' + d.link)
      .attr("height", d => d.height)
      .attr("width", d => d.width)
      .attr("x", 0)
      .attr("y", 0);
    image.exit().remove();
    image.attr("height", d => d.height)
      .attr("width", d => d.width);

    // BEGIN over image update (anchors, tools, etc)
    let over = children.selectAll('.' + Classes.OVER_CHILD_CLASS).data(d => [d], d => d.link);
    over.enter().append('g')
      .attr('class', Classes.OVER_CHILD_CLASS)
      .attr('id', d=> 'OVER-' + d.link);
    over.exit().remove();

    over = children.selectAll('.' + Classes.OVER_CHILD_CLASS);

    let annotations = over.selectAll('.' + Classes.ANNOTATIONS_CONTAINER_CLASS).data(d => [d], d => d.link);
    annotations.enter().append('g')
      .attr('class', Classes.ANNOTATIONS_CONTAINER_CLASS)
      .attr('id', d=> 'ANNOTATIONS-' + d.link);
    annotations.exit().remove();

    annotations = over.selectAll('.' + Classes.ANNOTATIONS_CONTAINER_CLASS);

    if(displays.angles) {
      let angle = annotations.selectAll('.' + Classes.AOI_CLASS).data(d => d.aois, d => d.uid);
      angle.enter().append('polyline')
        .attr('class', Classes.AOI_CLASS)
        .attr('id', d => 'AOI-' + d.uid)
        .attr('fill', 'none')
        .attr('stroke', d => colors[d.uid]?colors[d.uid][0]:'red')
        .attr('points', d => d.polygonVertices.replace(/\]/g, '').replace(/\[/g, '').replace(/\,/g, ' '))
        .attr('stroke-width', 4)
        .style('pointer-events', 'none')
        .style('outline-style', d => colors[d.uid]?'solid':null)
        .style('outline-width', 2/self.view.scale + 'px')
        .style('outline-color', d => colors[d.uid]? colors[d.uid][0]:null);
      angle.exit().remove();
      angle.attr('points', d => d.polygonVertices.replace(/\]/g, '').replace(/\[/g, '').replace(/\,/g, ' '))
        .attr('stroke', d => colors[d.uid]?colors[d.uid][0]:'red')
        .style('outline-style', d => colors[d.uid]?'solid':null)
        .style('outline-width', 2/self.view.scale + 'px')
        .style('outline-color', d => colors[d.uid]? colors[d.uid][0]:null);
    }
    else {
      annotations.selectAll('.' + Classes.AOI_CLASS).remove();
    }

    if(displays.trails) {
      let path = annotations.selectAll('.' + Classes.PATH_CLASS).data(d => d.tois, d => d.uid);
      path.enter().append('polyline')
        .attr('class', Classes.PATH_CLASS)
        .attr('id', d => 'PATH-' + d.uid)
        .attr('fill', 'none')
        .attr('stroke', d => colors[d.uid]?colors[d.uid][0]:'red')
        .attr('points', d => d.polygonVertices.replace(/\]/g, '').replace(/\[/g, '').replace(/\,/g, ' '))
        .attr('stroke-width', 4)
        .style('pointer-events', 'none')
        .style('outline-style', d => colors[d.uid]?'solid':null)
        .style('outline-width', 2/self.view.scale + 'px')
        .style('outline-color', d => colors[d.uid]? colors[d.uid][0]:null);
      path.exit().remove();
      path.attr('points', d => d.polygonVertices.replace(/\]/g, '').replace(/\[/g, '').replace(/\,/g, ' '))
        .attr('stroke', d => colors[d.uid]?colors[d.uid][0]:'red')
        .style('outline-style', d => colors[d.uid]?'solid':null)
        .style('outline-width', 2/self.view.scale + 'px')
        .style('outline-color', d => colors[d.uid]? colors[d.uid][0]:null);
    }
    else {
      annotations.selectAll('.' + Classes.PATH_CLASS).remove();
    }

    if(displays.points) {
      let point = annotations.selectAll('.' + Classes.POI_CLASS).data(d => d.pois, d => d.uid);
      let poi = point.enter().append('g')
        .attr('class', Classes.POI_CLASS)
        .attr('id', d => 'POI-' + d.uid)
        .attr('transform', d => 'translate(' + d.x + ',' + d.y + ')')
        .style('outline-style', d => colors[d.uid]?'solid':null)
        .style('outline-width', 4/self.view.scale + 'px')
        .style('outline-color', d => colors[d.uid]? colors[d.uid][0]:null)
        .style('pointer-events', 'none');
      poi.append('svg:image')
        .attr('height', 100)
        .attr('width', 60)
        .attr('xlink:href', markerSVG)
        .attr("x", -30)
        .attr("y", -100);
      point.exit().remove();
      point.attr('transform', d => 'translate(' + d.x + ',' + d.y + ')')
        .style('outline-style', d => colors[d.uid]?'solid':null)
        .style('outline-width', 4/self.view.scale + 'px')
        .style('outline-color', d => colors[d.uid]? colors[d.uid][0]:null);
    }
    else {
      annotations.selectAll('.' + Classes.POI_CLASS).remove();
    }

    if(displays.regions) {
      let region = annotations.selectAll('.' + Classes.ROI_CLASS).data(d => d.rois, d => d.uid);
      region.enter().append('polygon')
        .attr('class', Classes.ROI_CLASS)
        .attr('id', d => 'ROI-' + d.uid)
        .attr('points', d => d.polygonVertices.replace(/\]/g, '').replace(/\[/g, '').replace(/\,/g, ' '))
        .attr('fill', d => colors[d.uid]?colors[d.uid][0]:'blue')
        .attr('fill-opacity', 0.3)
        .style('pointer-events', 'none')
        .style('outline-style', d => colors[d.uid]?'solid':null)
        .style('outline-width', 2/self.view.scale + 'px')
        .style('outline-color', d => colors[d.uid]? colors[d.uid][0]:null);
      region.exit().remove();
      region.attr('points', d => d.polygonVertices.replace(/\]/g, '').replace(/\[/g, '').replace(/\,/g, ' '))
        .attr('fill', d => colors[d.uid]?colors[d.uid][0]:'blue')
        .style('outline-style', d => colors[d.uid]?'solid':null)
        .style('outline-width', 2/self.view.scale + 'px')
        .style('outline-color', d => colors[d.uid]? colors[d.uid][0]:null);
    }
    else {
      annotations.selectAll('.' + Classes.ROI_CLASS).remove();
    }
    // END over image update
  }

  /**
   * This is a callback to display an image after it has finished loading in the background.
   * @param data data element of the entity.
   * @param image Image after it has finished loading.
   */
  static displayLoadedImage(data, image) {
    let group = d3.selectAll("." + Classes.CHILD_GROUP_CLASS);

    group.select("#IMAGE-" + data.link)
      .attr("xlink:href", image.src);
  }

  /**
   * Provides the image URL corresponsing to the visible proportion of the image. Thresholds are :
   * - under 20% visible area : thumbnail url
   * - between 20% and 70% visible area : intermediary image url
   * - over 70% visible area : full-size image url
   * When a url is not provided the function moves to the highest size available.
   * @param d Data of the displayed element, must contain displayHeight, displayWidth & various url properties
   * @param view View data as contained in ViewStore component.
   */
  static getImageUrlFromVisibleProportion(d, view) {
    let proportion = (d.displayHeight) / (view.yMax - view.yMin);
    if(proportion < 0.2) {
      return D3ViewUtils.getImageUrlFromQuality(d, ViewConstants.imageQuality.Low);
    } else if(proportion < 0.7) {
      return D3ViewUtils.getImageUrlFromQuality(d, ViewConstants.imageQuality.High);
    } else {
      return D3ViewUtils.getImageUrlFromQuality(d, ViewConstants.imageQuality.Original);
    }
  }

  /**
   * Retrieve image URL corresponding to given quality
   * @param data Image data, must have at least a 'url' field and should also have a 'thumbnail' field. If the thumbnail field is provided, it is assumed to be a ReColNat image and the intermediary image is calculated from it.
   * @param quality One of the values provided in ViewConstants.imageQuality
   */
  static getImageUrlFromQuality(data, quality) {
    switch(quality) {
      case ViewConstants.imageQuality.Low:
        return data.thumbnail;
      case ViewConstants.imageQuality.High:
        // ex http://imager.mnhn.fr/imager2/w400/2012/11/20/6/P00048663.jpg
        return data.thumbnail.replace('v25', 'w400');
      case ViewConstants.imageQuality.Original:
        return data.url;
      default:
        return data.thumbnail;
    }
  }

  /**
   * Animates the border of the entity selected by the provided id. This is used for example to outline anchors.
   * @param id UUID of the entity
   */
  static animateOutline(id) {
    let d3Node = d3.select('#' + id);
    d3Node
      .classed('outline', true)
      .style('outline-style', 'solid')
      .style('outline-width', '2px');

      function repeat() {
        d3Node.style('outline-color', 'black')
          .transition()
          .duration(500)
          .ease('linear')
          .style('outline-color', 'white')
          .transition()
          .duration(500)
          .ease('linear')
          .style('outline-color', 'black')
        .each('end', repeat);
      }
    repeat();
  }

  /**
   * Stops the animation started by animateOutline for the provided id.
   */
  static stopOutlineAnimation(id) {
    d3.select('#' + id).classed('outline', false).interrupt().transition()
      .style('outline-color', null)
      .style('outline-width', null)
      .style('outline-style', 'none');
  }

  /**
   * Moves the view to the object described by the provided data.
   * Internally, as the object may not be drawn in the DOM, this calculates the coordinates of the bounding box, creates the box, moves the view towards the box and removes the box. This is done to avoid the headache of trigonometry (due to axis transformation in D3).
   * @param objectData data of the object to be zoomed on
   * @param benchstore the LabBenchStore
   * @param view current view data as contained in ViewStore
   */
  static zoomToObject(objectData, benchstore, view) {
    let d3linkId = null;
    let coords = null;
    switch(objectData.type) {
      case 'Image':
        if(objectData.link) {
          d3linkId = objectData.link;
        } else {
          let displayData = benchstore.getDisplayData(objectData.uid);
          d3linkId = displayData.link;
        }
        D3ViewUtils.zoomToObjectInternal('#GROUP-' + d3linkId, view);
        return;
      case 'PointOfInterest':
        coords = {
          x: objectData.x - 30,
          y: objectData.y - 100,
          width: 60,
          height: 100
        };
        break;
      case 'RegionOfInterest':
      case 'AngleOfInterest':
      case 'TrailOfInterest':
        let vertices = JSON.parse(objectData.polygonVertices);
        coords = {
          x: _.chain(vertices).map(v => v[0]).reduce((m,n) => Math.min(m,n)).value(),
          y: _.chain(vertices).map(v => v[1]).reduce((m,n) => Math.min(m,n)).value(),
        };
        coords.width = _.chain(vertices).map(v => v[0]).reduce((m,n) => Math.max(m,n)).value() - coords.x;
        coords.height = _.chain(vertices).map(v => v[1]).reduce((m,n) => Math.max(m,n)).value() - coords.y;
        break;
      default:
        console.error('No handler for type ' + objectData.type);
        return;
    }

    let imageId = objectData.parents[0];
    let displayData = benchstore.getDisplayData(imageId);
    d3linkId = displayData.link;

    // Draw useless item on this image and zoom on it, letting automatic draw-on-pan take over
    d3.select('#ANNOTATIONS-' + d3linkId)
      .append('rect')
      .attr('id', 'ZOOMER')
      .attr('x', coords.x)
      .attr('y', coords.y)
      .attr('height', coords.height)
      .attr('width', coords.width);

    D3ViewUtils.zoomToObjectBySelector('#ZOOMER', view);
    d3.select('#ZOOMER').remove();
  }

  /**
   * Center view upon an object using a d3 selector to find the object. Object must be in DOM for this method to work.
   * @param d3selector String the selector (including any leading punctuation)
   * @param view current view data as contained in ViewStore
   */
  static zoomToObjectBySelector(d3selector, view) {
    // Retrieve object coordinates and size in browser window
    let object = d3.select(d3selector);
    let winLoc = object.node().getBoundingClientRect();
    let oldHeight = winLoc.height;
    let oldWidth = winLoc.width;
    let oldScale = view.scale;

    // Calculate fitting area
    let scale = 1.0;
    if(oldHeight > oldWidth) {
      scale = (view.height * oldScale) / (oldHeight);
    }
    else {
      scale = (view.width * oldScale) / (oldWidth);
    }
    scale = scale*0.90;

    // Leave half empty screen as margin to center the object in the viewport
    let marginX = (view.width - oldWidth*scale/view.scale)/2;
    let marginY = (view.height - oldHeight*scale/view.scale)/2;

    // Dispatch action
    window.setTimeout(ViewActions.updateViewport.bind(null,
      (view.left - winLoc.left + view.leftFromWindow)*scale/view.scale + marginX,
      (view.top - winLoc.top + view.topFromWindow)*scale/view.scale + marginY,
      null,
      null,
      scale,
      true
    ), 10);
  }

  /**
   * Checks if the given element is currently in the visible area of a workbench.
   * @param data data of the element
   * @param view current view data as contained in ViewStore
   */
  static isElementInView(data, view) {
    return !((data.x + data.displayWidth) < view.xMin
    || data.x > view.xMax
    || (data.y + data.displayHeight) < view.yMin
    || data.y > view.yMax);
  }

  /**
   * Retrieves the selector of an element in D3 according to its 'type' property.
   * @param data
   */
  static findHilightD3Selector(data) {
    switch(data.type) {
      case 'Image':
        return '#BORDER-' + data.uid;
        break;
      case 'PointOfInterest':
        return '#POI-' + data.uid;
        break;
      case 'RegionOfInterest':
        return '#ROI-' + data.uid;
        break;
      case 'TrailOfInterest':
        return '#PATH-' + data.uid;
        break;
      case 'AngleOfInterest':
        return '#AOI-' + data.uid;
        break;
      default:
        console.warn('Element type not displayed in D3 : ' + data.type);
    }
  }
}
